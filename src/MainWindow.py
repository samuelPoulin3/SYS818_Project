#! /usr/bin/env python3

""" MainWindow of Classification algorithm

    This is the main window of the algorithm.
"""
import os
import sys

from PyQt5 import QtCore
from PyQt5 import QtWidgets
import pandas as pd
import numpy as np
from scipy.sparse import csr_matrix, vstack
from sklearn.cluster import KMeans
from PyQt5.QtWidgets import QFileSystemModel, QFileDialog
from plugins.ImportSubjects import ImportSubjects
from ui.Ui_MainWindow import Ui_MainWindow
from plugins.ScanShow.ScanShow import ScanShow
from collections import defaultdict
from PyQt5.QtWidgets import QTableWidgetItem
from commons.Models import Models_keypoints, Models_Clustering
from plugins import layers
from concurrent import futures
from multiprocessing import Manager, Process
import queue
import threading
import time
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense
from keras import callbacks
from PIL import Image
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt

DEBUG = False

class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    stop_signal = QtCore.pyqtSignal()

    """Main Window."""
    def __init__(self, *args, **kwargs):
        super(MainWindow, self).__init__(*args, **kwargs)
        # Setup the Ui_MainWindow generated by QtDesigner
        self.setupUi(self)
        self.model = QFileSystemModel()
        self.model.setRootPath(os.path.expanduser('~'))
        self.prepare_dataset.setVisible(False)
        ################### Remove this before final version #################
        self.subjects_path_lineEdit.setText("C:/Users/sampo/Python/PycharmProjects/SYS818_Project/Data/subjects")

        # Init internal variables
        self._subject_path = None

    def on_new(self):
        """
        Blabla
        """
        pass

    def on_open(self):
        """
        Blabla
        """
        self._subject_path = QFileDialog.getExistingDirectory(
            self, 
            "Open Directory",
            "/home",
            QFileDialog.ShowDirsOnly
            | QFileDialog.DontResolveSymlinks)
        
        if self._subject_path == '' and self.subjects_path_lineEdit.text() == '':
            err_message = "ERROR MainWindow: no path selected"
            print(err_message)
        elif not self._subject_path == '' and self.subjects_path_lineEdit.text() == '':
            self.subjects_path_lineEdit.setText(self._subject_path)
        elif not self._subject_path == '' and not self.subjects_path_lineEdit.text() == '':
            self.subjects_path_lineEdit.setText(self._subject_path)

    def on_save(self):
        """
        Blabla
        """
        pass

    def on_exit(self):
        """ 
        Blabla
        """
        pass

    def on_run(self):
        """
        Blabla
        """
        self._subject_path = self.subjects_path_lineEdit.text()
        self.info_subjects = ImportSubjects(self._subject_path)

        # QtDesigner show second section
        self.prepare_dataset.setVisible(True)
        self.subjects_found_lineEdit.setText(str(self.info_subjects.nb_images))            

    def reshape_data(self):
        self.subjects_train_pour = self.subjects_train_spinBox.value() / 100
        self.subjects_test_pour = self.subjects_test_spinBox.value() / 100
        if self.subjects_train_pour + self.subjects_test_pour > 1:
            err_message = "ERROR reshape_data pourcentage over 100%"
            print(err_message)

        self.number_epochs = self.number_epochs_spinBox.value()
        self.batch_size = self.batch_size_spinBox.value()

        self.label_table = {'Male': 0.0,
                            'Female': 1.0,
                            'Right': 0.0,
                            'Left': 1.0,
                            'None': 0,
                            '0.0': 0,
                            '0.5': 1,
                            '1.0': 1,
                            '2.0': 1}

        train = 0
        self.labels = []
        self.use_train = []
        
        self.labels_train = []
        self.data_train = []
        subjects_train = int(self.info_subjects.nb_images * self.subjects_train_pour)
        for subject in self.info_subjects.subjects:
            self.use_train.append(subject)
            for scan in self.info_subjects.subjects[subject].scans:
                self.data_train.append([self.info_subjects.subjects[subject].scans[scan].pixels])
                if self.gender_checkBox.isChecked():
                    if not 'gender' in self.labels:
                        self.labels.append('gender')
                    self.labels_train.append(self.label_table[self.info_subjects.subjects[subject].gender])

                if self.hand_checkBox.isChecked():
                    if not 'hand' in self.labels:
                        self.labels.append('hand')
                    self.labels_train.append(self.label_table[self.info_subjects.subjects[subject].hand])

                if self.age_checkBox.isChecked():
                    if not 'age' in self.labels:
                        self.labels.append('age')
                    self.labels_train.append(self.info_subjects.subjects[subject].age)

                if self.educ_checkBox.isChecked():
                    if not 'educ' in self.labels:
                        self.labels.append('educ')
                    self.labels_train.append(self.info_subjects.subjects[subject].educ)

                if self.ses_checkBox.isChecked():
                    if not 'ses' in self.labels:
                        self.labels.append('ses')
                    self.labels_train.append(self.info_subjects.subjects[subject].ses)

                if self.mmse_checkBox.isChecked():
                    if not 'mmse' in self.labels:
                        self.labels.append('mmse')
                    self.labels_train.append(self.info_subjects.subjects[subject].mmse)

                if self.cdr_checkBox.isChecked():
                    if not 'cdr' in self.labels:
                        self.labels.append('cdr')
                    self.labels_train.append(self.label_table[str(self.info_subjects.subjects[subject].cdr)])

                if self.e_tiv_checkBox.isChecked():
                    if not 'e_tiv' in self.labels:
                        self.labels.append('e_tiv')
                    self.labels_train.append(self.info_subjects.subjects[subject].e_tiv)

                if self.n_wbv_checkBox.isChecked():
                    if not 'n_wbv' in self.labels:
                        self.labels.append('n_wbv')
                    self.labels_train.append(self.info_subjects.subjects[subject].n_wbv)

                if self.asf_checkBox.isChecked():
                    if not 'asf' in self.labels:
                        self.labels.append('asf')
                    self.labels_train.append(self.info_subjects.subjects[subject].asf)

                if self.delay_checkBox.isChecked():
                    if not 'delay' in self.labels:
                        self.labels.append('delay')
                    self.labels_train.append(self.info_subjects.subjects[subject].delay)

                train += 1
                if train >= subjects_train:
                    break
            if train >= subjects_train:
                    break
        
        self.data_train = np.array(self.data_train).reshape((subjects_train, 256, 256, 1))
        self.data_train = self.data_train.astype('float32') / np.array([255])
        self.data_train = csr_matrix(np.reshape(self.data_train,(subjects_train,256*256)))

        self.labels_train = np.array(self.labels_train).reshape((subjects_train, len(self.labels)))

        test = 0
        self.use_test = []

        self.labels_test = []
        self.data_test = []
        subjects_test = int(self.info_subjects.nb_images * self.subjects_test_pour)
        for subject in (subject for subject in self.info_subjects.subjects if subject not in self.use_train):
            self.use_test.append(subject)
            for scan in self.info_subjects.subjects[subject].scans:
                self.data_test.append([self.info_subjects.subjects[subject].scans[scan].pixels])
                if self.gender_checkBox.isChecked():
                    if not 'gender' in self.labels:
                        self.labels.append('gender')
                    self.labels_test.append(self.label_table[self.info_subjects.subjects[subject].gender])

                if self.hand_checkBox.isChecked():
                    if not 'hand' in self.labels:
                        self.labels.append('hand')
                    self.labels_test.append(self.label_table[self.info_subjects.subjects[subject].hand])

                if self.age_checkBox.isChecked():
                    if not 'age' in self.labels:
                        self.labels.append('age')
                    self.labels_test.append(self.info_subjects.subjects[subject].age)

                if self.educ_checkBox.isChecked():
                    if not 'educ' in self.labels:
                        self.labels.append('educ')
                    self.labels_test.append(self.info_subjects.subjects[subject].educ)

                if self.ses_checkBox.isChecked():
                    if not 'ses' in self.labels:
                        self.labels.append('ses')
                    self.labels_test.append(self.info_subjects.subjects[subject].ses)

                if self.mmse_checkBox.isChecked():
                    if not 'mmse' in self.labels:
                        self.labels.append('mmse')
                    self.labels_test.append(self.info_subjects.subjects[subject].mmse)

                if self.cdr_checkBox.isChecked():
                    if not 'cdr' in self.labels:
                        self.labels.append('cdr')
                    self.labels_test.append(self.label_table[str(self.info_subjects.subjects[subject].cdr)])

                if self.e_tiv_checkBox.isChecked():
                    if not 'e_tiv' in self.labels:
                        self.labels.append('e_tiv')
                    self.labels_test.append(self.info_subjects.subjects[subject].e_tiv)

                if self.n_wbv_checkBox.isChecked():
                    if not 'n_wbv' in self.labels:
                        self.labels.append('n_wbv')
                    self.labels_test.append(self.info_subjects.subjects[subject].n_wbv)

                if self.asf_checkBox.isChecked():
                    if not 'asf' in self.labels:
                        self.labels.append('asf')
                    self.labels_test.append(self.info_subjects.subjects[subject].asf)

                if self.delay_checkBox.isChecked():
                    if not 'delay' in self.labels:
                        self.labels.append('delay')
                    self.labels_test.append(self.info_subjects.subjects[subject].delay)

                test += 1
                if test >= subjects_test:
                    break
            if test >= subjects_test:
                    break

        self.data_test = np.array(self.data_test).reshape((subjects_test, 256, 256, 1))
        self.data_test = self.data_test.astype('float32') / np.array([255])
        self.data_test = csr_matrix(np.reshape(self.data_test,(subjects_test,256*256)))

        self.labels_test = np.array(self.labels_test).reshape((subjects_test, len(self.labels)))
 
        #self.find_keypoints(self.data_train)
        #self.find_keypoints(self.data_test)

        self.data_train_csv = pd.read_csv("C:/Users/sampo/Python/PycharmProjects/SYS818_Project/keypoints_train_2.csv")
        self.data_test_csv = pd.read_csv("C:/Users/sampo/Python/PycharmProjects/SYS818_Project/keypoints_test_2.csv")

        self.compute_model(self.data_train_csv, self.labels_train, self.data_test_csv, self.labels_test, self.number_epochs, self.batch_size)

    def find_keypoints(self, data):
    
        # Best sampling frequency
        shape_theta = (16, 16)
        threshold = 0.03
        s = 3
        k = 2 ** (1/s)

        # First octave
        size_1_1 = (256, 256)
        shape_1_1 = (3,3)
        sigma_1_1 = 1.6
        
        shape_1_2 = (3,3)
        sigma_1_2 = k * sigma_1_1 - sigma_1_1
        
        shape_1_3 = (3,3)
        sigma_1_3 = (k ** 2) * sigma_1_1 - (k * sigma_1_1)
        
        shape_1_4 = (3,3)
        sigma_1_4 = (k ** 3) * sigma_1_1 - ((k ** 2) * sigma_1_1)

        # second octave
        resample = 2
        size_2_1 = (256 // resample, 256 // resample)
        shape_2_1 = (3,3)
        sigma_2_1 = sigma_1_4
        
        shape_2_2 = (3,3)
        sigma_2_2 = (k ** 4) * sigma_1_1 - ((k ** 3) * sigma_1_1)
        
        shape_2_3 = (3,3)
        sigma_2_3 = (k ** 5) * sigma_1_1 - ((k ** 4) * sigma_1_1)
        
        shape_2_4 = (3,3)
        sigma_2_4 = (k ** 6) * sigma_1_1 - ((k ** 5) * sigma_1_1)

        # Third octave
        size_3_1 = (128 // resample, 128 // resample)
        shape_3_1 = (3,3)
        sigma_3_1 = sigma_2_4
        
        shape_3_2 = (3,3)
        sigma_3_2 = (k ** 7) * sigma_1_1 - ((k ** 6) * sigma_1_1)
        
        shape_3_3 = (3,3)
        sigma_3_3 = (k ** 8) * sigma_1_1 - ((k ** 7) * sigma_1_1)
        
        shape_3_4 = (3,3)
        sigma_3_4 = (k ** 9) * sigma_1_1 - ((k ** 8) * sigma_1_1)
        

        model = Models_keypoints()
        # Add first octave
        model.add(layers.Gauss2D(size_1_1, shape_1_1, sigma_1_1))
        model.add(layers.Gauss2D(size_1_1, shape_1_2, sigma_1_2))
        model.add(layers.Gauss2D(size_1_1, shape_1_3, sigma_1_3))
        model.add(layers.Gauss2D(size_1_1, shape_1_4, sigma_1_4))

        model.add(layers.GaussDiff(size_1_1,
                                   [shape_1_1, shape_1_2, shape_1_3, shape_1_4],
                                   [sigma_1_1, sigma_1_2, sigma_1_3, sigma_1_4],
                                   shape_theta,
                                   threshold))

        model.add(layers.Resampling(size_1_1, resample))

        # Add second octave
        model.add(layers.Gauss2D(size_2_1, shape_2_1, sigma_2_1))
        model.add(layers.Gauss2D(size_2_1, shape_2_2, sigma_2_2))
        model.add(layers.Gauss2D(size_2_1, shape_2_3, sigma_2_3))

        model.add(layers.GaussDiff(size_2_1,
                                   [shape_2_1, shape_2_2, shape_2_3, shape_2_4],
                                   [sigma_2_1, sigma_2_2, sigma_2_3, sigma_2_4],
                                   shape_theta,
                                   threshold))

        model.add(layers.Resampling(size_2_1, resample))

        # Add third octave
        model.add(layers.Gauss2D(size_3_1, shape_3_1, sigma_3_1))
        model.add(layers.Gauss2D(size_3_1, shape_3_2, sigma_3_2))
        model.add(layers.Gauss2D(size_3_1, shape_3_3, sigma_3_3))

        model.add(layers.GaussDiff(size_3_1,
                                   [shape_3_1, shape_3_2, shape_3_3, shape_3_4],
                                   [sigma_3_1, sigma_3_2, sigma_3_3, sigma_3_4],
                                   shape_theta,
                                   threshold))

        #model.add(layers.FeatExtract())
        

        model.fit(data)

        #model.keypoints.to_csv("C:/Users/sampo/Python/PycharmProjects/SYS818_Project/keypoints_train.csv")
        #model.keypoints.to_csv("C:/Users/sampo/Python/PycharmProjects/SYS818_Project/keypoints_test.csv")

        #show_images = ScanShow(self.info_subjects, self.use_train, self.data_train)
        show_images = ScanShow(self.info_subjects, self.use_train, self.data_train, model.new_mat)
        show_images.show()
        a = 1

    def compute_model(self, data_train, labels_train, data_test, labels_test, number_epochs, batch_size):
        
        data_train['image_label'] = labels_train[data_train['image_no']]

        pos_train = np.vstack((data_train['x'], data_train['y'])).T.astype(int)
        
        kmeans = KMeans(n_clusters=13, init='random', n_init=10, max_iter=300, tol=1e-4, verbose=1, random_state=0, algorithm="auto").fit(pos_train)
        model_clustering = Models_Clustering(kmeans)
        #model_clustering.show_centers(self.data_train[0])
        data_train['kmeans_label'] = model_clustering.kmeans.labels_

        model = []
        clusters = {}
        for i in range(0,model_clustering.kmeans.n_clusters):
            # mlp for binary classification
            # determine the number of input features
            data_train_clusters = data_train[data_train['kmeans_label'] == i].loc[:, ~data_train.columns.isin(['image_no', 'keypoint_no', 'image_label', 'kmeans_label'])]
            #self.show_images(data_train_clusters['x'].values, data_train_clusters['y'].values)
            data_train_clusters = data_train_clusters.to_numpy()
            label_train_clusters = data_train[data_train['kmeans_label'] == i]['image_label'].values
            n_features = data_train_clusters.shape[1]
            # define model
            model = Sequential()
            model.add(Dense(64, activation='relu', kernel_initializer='he_normal', input_shape=(n_features,)))
            model.add(Dense(10, activation='softmax'))
            model.add(Dense(1, activation='sigmoid'))

            # compile the model
            model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])

            earlystopping = callbacks.EarlyStopping(monitor ="accuracy", 
                                                    mode ="max", patience = 5, 
                                                    restore_best_weights = True)

            # fit the model
            hist = model.fit(data_train_clusters, 
                             label_train_clusters, 
                             epochs=number_epochs, 
                             batch_size=batch_size, 
                             verbose=1, 
                             callbacks =[earlystopping])

            # Save model
            key_name = 'clusters_' + str(i)
            clusters[key_name] = hist

        weights_acc = np.array([clusters[list(clusters.keys())[i]].history.get('accuracy')[-1] for i in range(model_clustering.kmeans.n_clusters)])
        weights_acc = weights_acc ** 2
        weights_acc = weights_acc / np.max(weights_acc)
        weights_acc = np.reshape(weights_acc,(len(weights_acc),1))

        # Test 
        data_test['image_label'] = labels_test[data_test['image_no']]

        pos_test = np.vstack((data_test['x'], data_test['y'])).T.astype(int)
        data_test['kmeans_label'] = model_clustering.kmeans.predict(pos_test)

        clusters_test = {}
        for i in range(0,model_clustering.kmeans.n_clusters):
            # mlp for binary classification
            # determine the number of input features
            data_test_clusters = data_test[data_test['kmeans_label'] == i].loc[:, ~data_test.columns.isin(['image_no', 'keypoint_no', 'image_label', 'kmeans_label'])]
            #self.show_images(data_test_clusters['x'].values, data_test_clusters['y'].values)
            data_test_clusters = data_test_clusters.to_numpy()
            label_test_clusters = data_test[data_test['kmeans_label'] == i]['image_label'].values
            n_features = data_test_clusters.shape[1]
            key_name = 'clusters_' + str(i)
            clusters_test[key_name] = clusters[key_name].model.predict(data_test_clusters, verbose=1)
            # cm = (confusion_matrix(np.argmax(clusters_test[key_name],axis=1), np.argmax(clusters_test[key_name],axis=1)))
            # self.plot_confusion_matrix(cm, None, normalize=False, title='Confusion matrix', cmap=plt.cm.Blues)
            # text_label='ROC CNN'
            # self.plot_roc(label_test_clusters, clusters_test[key_name], text_label)
        data_test['predicted_label'] = 0
        index = data_test.index
        for i in range(0,model_clustering.kmeans.n_clusters):
            condition = data_test['kmeans_label'] == i
            kmeans_label_indices = index[condition]
            kmeans_indices_list = kmeans_label_indices. tolist()
            data_test.loc[kmeans_indices_list,'predicted_label'] = clusters_test[list(clusters_test.keys())[i]]
        
        image_cluster = np.zeros((model_clustering.kmeans.n_clusters,1))
        vec_pred_label = []
        for i in range(np.max(data_test['image_no'].to_numpy())):
            image_all_clusters = data_test[data_test['image_no'] == i]
            for j in range(model_clustering.kmeans.n_clusters):
                image_cluster[j] = np.sum(image_all_clusters[image_all_clusters['kmeans_label'] == j]['predicted_label'].values)
            vec_pred_label.append(image_cluster)

        new_label = np.zeros((len(vec_pred_label),1))
        for i in range(len(vec_pred_label)):
            new_label[i] = np.dot(np.reshape(vec_pred_label[i],(1,model_clustering.kmeans.n_clusters)),weights_acc)
        a = 1
        
    def show_images(self, points_x, points_y):
        # Get matrix of keypoints
        image = np.reshape(self.data_train[0].toarray(),(256,256,1))
        images_RGB = np.reshape(np.repeat(image, 3),(256*256,3))
        images_RGB = np.reshape(images_RGB,(256,256,3))
        if len(points_x) > 0 and len(points_y) > 0:
            images_RGB[points_x.astype(int),points_y.astype(int),:] = np.array([1,0,0])
        img = Image.fromarray(np.uint8(images_RGB * 255), "RGB")
        img.show()

    # Plotting the confusion matrix
    def plot_confusion_matrix(self, cm, classes,
                            normalize=False,
                            title='Confusion matrix',
                            cmap=plt.cm.Blues):
        import itertools
        plt.figure(figsize=(12,12))
        plt.imshow(cm, interpolation='nearest', cmap=cmap)
        plt.title(title)
        plt.colorbar()
        if classes!=None:
            tick_marks = np.arange(len(classes))
            plt.xticks(tick_marks, classes, rotation=45)
            plt.yticks(tick_marks, classes)

        if normalize:
            cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
            print("Normalized confusion matrix")
        else:
            print('Confusion matrix, without normalization')

        thresh = cm.max() / 2.
        for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
            plt.text(j, i, cm[i, j],
                    horizontalalignment="center",
                    color="white" if cm[i, j] > thresh else "black")

        plt.tight_layout()
        plt.ylabel('True label')
        plt.xlabel('Predicted label')
        plt.show()
        
        
    def plot_roc(self, y_test, y_pred, text_label):
        from sklearn.metrics import roc_curve, auc
        fpr, tpr, _ = roc_curve(y_test[:, 1], y_pred[:, 1])
        roc_auc = auc(fpr, tpr)
        
        plt.figure(figsize=(7,7))
        lw=2
        alpha=1
        plt.plot([0,1],[0,1],linestyle = '--',lw = 2,color = 'black')
        plt.plot(fpr, tpr, 
                label= text_label+r' (AUC = %0.2f )' % (roc_auc),lw=lw, alpha=alpha)

        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('ROC Male-Female Classification')
        plt.legend(loc="lower right")
        plt.show()

    def on_stop(self):
        """ Blabla """
        pass

    def quit(self):
        """ quit the app """
        sys.exit()
